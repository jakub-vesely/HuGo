
/*
 * Copyright (c) 2020 jakub-vesely
 * This software is published under MIT license. Full text of the licence is available at https://opensource.org/licenses/MIT
 *
 * This component is based on https://github.com/yanbe/ssd1306-esp-idf-i2c
 */

#include "ssd1306.h"
#include <event_loop.h>
#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <i2c.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <hugo_tiny_block_defines.h>
#include <display_adapter.h>

#define TAG "ssd_1306"
//#define COLUMNS 64
//#define PAGES 6 //6 pages for 48 lines, use 8 pages for 64 lines
#define PAGE_SIZE  8 //8 bits
//#define BUFFER_SIZE (COLUMNS * PAGES)

#define OLED_I2C_ADDRESS   0x3d // SLA (0x3C) + WRITE_MODE (0x00) =  0x78 (0b01111000)

#define OLED_CONTROL_BYTE_CMD_STREAM    0x00
#define OLED_CONTROL_BYTE_DATA_STREAM   0x40
#define OLED_CONTROL_BYTE_CMD_SINGLE    0x80

#define OLED_CMD_SET_LOWER_START_COLUMN 0x00
#define OLED_CMD_SET_UPPER_START_COLUMN 0x10
#define OLED_CMD_MEMORY_MODE            0x20
#define OLED_CMD_COLUMN_ADDR            0x21
#define OLED_CMD_SET_START_LINE         0x40
#define OLED_CMD_SET_CONTRAST           0x81
#define OLED_CMD_SET_CHARGE_PUMP        0x8D
#define OLED_CMD_SET_SEGMENT_REMAP      0xA1
#define OLED_CMD_DISPLAY_ALLON_RESUME   0xA4
#define OLED_CMD_SET_NORMAL_DISPLAY     0xA7
#define OLED_CMD_SET_INVERT_DISPLAY     0xA6
#define OLED_CMD_SET_MULTIPLEX          0xA8
#define OLED_CMD_DISPLAY_OFF            0xAE
#define OLED_CMD_DISPLAY_ON             0xAF
#define OLED_CMD_SET_COM_SCAN_MODE      0xC0
#define OLED_CMD_SET_COM_PINS           0xDA
#define OLED_CMD_SET_DISPLAY_OFFSET     0xD3
#define OLED_CMD_SET_DISPLAY_CLOCK_DIV  0xD5
#define OLED_CMD_SET_PRECHARGE          0xD9
#define OLED_CMD_SET_VCOM_DETECT        0xDB

static int s_init_event_id = -1;
static int s_flush_event_id = -1;

void _clean_buffer(display_adapter_t *pAdapter) {
    memset(pAdapter->buffer, pAdapter->invert ? 0xff : 0, pAdapter->buffer_size);
}

static void _flush(display_adapter_t* pAdapter){
    for (uint8_t row = 0; row < pAdapter->height / PAGE_SIZE; ++row) {
        uint8_t select_block = 0xB0 | row;
        hugo_i2c(pAdapter->address, OLED_CONTROL_BYTE_CMD_SINGLE, &select_block, 1, NULL, 0);

        //this block doesn't have to be hre for 128x64. It is necessary to return pointer home when size is smaller, otherwise it returns automatically
        {
            //it seems that 64x48 displays are moved 32 pixels left - setting hier bit reduce this shift
            uint8_t data[2];
            data[0] = OLED_CMD_SET_LOWER_START_COLUMN | 0;
            data[1] = OLED_CMD_SET_UPPER_START_COLUMN | 0x02;
            hugo_i2c(pAdapter->address, OLED_CONTROL_BYTE_CMD_STREAM, data, 2, NULL, 0);
        }

        hugo_i2c(pAdapter->address, OLED_CONTROL_BYTE_DATA_STREAM, pAdapter->buffer + row * pAdapter->width, pAdapter->width, NULL, 0);
    }
}

static void _init_ssd1306_event_action(event_data_t data, int _data_size) {
    display_adapter_t* pAdapter = *(display_adapter_t **)data;
    uint8_t init_sequence[] = {
        OLED_CMD_DISPLAY_OFF,
        OLED_CMD_SET_DISPLAY_CLOCK_DIV, 0x80, //suggested ratio for clockdiv
        OLED_CMD_SET_MULTIPLEX, 0x2f, //0x2F, //(0x3F for 64 lines), !!!change to 0x3F for 128x64
        OLED_CMD_SET_DISPLAY_OFFSET, 0x00,
        OLED_CMD_SET_START_LINE | 0x00,
        OLED_CMD_SET_CHARGE_PUMP, 0x14, //0x14 VCC generated by internal DC/DC circuit
        OLED_CMD_MEMORY_MODE, 0x00, //horizontal addressing (0x02 for page addressing)
        OLED_CMD_SET_SEGMENT_REMAP | 0x01, //no remap (0x01 for remap 180°)
        OLED_CMD_SET_COM_SCAN_MODE | 0x08,  //no rotation (use 0x08 for rotation 180°)
        OLED_CMD_SET_COM_PINS, 0x12,
        OLED_CMD_SET_CONTRAST, 0xCF,
        OLED_CMD_SET_PRECHARGE, 0xF1,
        OLED_CMD_SET_VCOM_DETECT, 0x40,
        OLED_CMD_DISPLAY_ALLON_RESUME,
        OLED_CMD_SET_INVERT_DISPLAY, //OLED_CMD_SET_NORMAL_DISPLAY, //FIXME:it seems the display logic is prepared to inverting
        OLED_CMD_COLUMN_ADDR, 0x00,
        0x7f, //RESET?
        OLED_CMD_DISPLAY_ON
    };
    ESP_LOGI("ssd", "display initializing, address: %d", pAdapter->address);
    hugo_i2c(pAdapter->address, OLED_CONTROL_BYTE_CMD_STREAM, init_sequence, sizeof(init_sequence), NULL, 0);

    _clean_buffer(pAdapter);
    _flush(pAdapter);
    pAdapter->initialized = true;
}

void _flush_event_action(event_data_t data, int _data_size) {
    display_adapter_t* pAdapter = *(display_adapter_t**)data;
    _flush(pAdapter);
}

static int _get_buff_pos(display_adapter_t *pAdapter, int x, int y) {
    return (y / PAGE_SIZE) * pAdapter->width + x;
}

bool _get_point(display_adapter_t *pAdapter, int x, int y) {
    return pAdapter->buffer[_get_buff_pos(pAdapter, x, y)];
}

bool _set_point(display_adapter_t * pAdapter, int x, int y, bool color) {
    if (x < 0 || x >= pAdapter->width || y < 0 || y >= pAdapter->height) {
        return false;
    }
    int buf_pos = _get_buff_pos(pAdapter, x, y);

    int value = 1 << (y % PAGE_SIZE);
    if (color != pAdapter->invert) {
        pAdapter->buffer[buf_pos] |= value;
    }
    else {
        pAdapter->buffer[buf_pos] &= ~value;
    }
    return true;
}

static void _showtime(display_adapter_t *pAdapter) {
    hugo_raise_event(EVENT_LOOP_TYPE_PERIPHERAL, s_flush_event_id, &pAdapter, sizeof(display_adapter_t *));
}

static void _register_events() {
    s_init_event_id = hugo_get_new_event_id(EVENT_LOOP_TYPE_PERIPHERAL);
    hugo_add_event_action(EVENT_LOOP_TYPE_PERIPHERAL, s_init_event_id, _init_ssd1306_event_action);

    s_flush_event_id = hugo_get_new_event_id(EVENT_LOOP_TYPE_PERIPHERAL);
    hugo_add_event_action(EVENT_LOOP_TYPE_PERIPHERAL, s_flush_event_id, _flush_event_action);
}

display_adapter_t *hugo_ssd1306_init(uint8_t i2c_address, uint8_t width, uint8_t height, bool invert) {
    display_adapter_t *pAdapter = (display_adapter_t*)malloc(sizeof(display_adapter_t));
    pAdapter->address = i2c_address;
    pAdapter->width = width;
    pAdapter->height = height;
    pAdapter->buffer_size = width * (height / PAGE_SIZE);
    pAdapter->buffer = malloc(pAdapter->buffer_size);
    pAdapter->invert = invert;
    pAdapter->initialized = false;

    pAdapter->get_point = _get_point;
    pAdapter->set_point = _set_point;
    pAdapter->clean = _clean_buffer;
    pAdapter->showtime = _showtime;

    _register_events();

    hugo_raise_event(EVENT_LOOP_TYPE_PERIPHERAL, s_init_event_id, &pAdapter, sizeof(display_adapter_t*));

    return pAdapter;
}
